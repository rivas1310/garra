A) Ajustes base al iniciar cada etiqueta

Agrega esto en startLabel() antes de CLS:

// Anclar origen y dibujar marco para ver centrado
this.commands.push(`REFERENCE 0,0`)     // (0,0) esquina superior izquierda
this.commands.push(`SHIFT 0`)          // sin desplazamiento global; afínalo si tu hardware lo necesita
this.commands.push(`DENSITY 8`)        // opcional
this.commands.push(`SPEED 4`)          // opcional
// Dibuja un marco de la etiqueta (útil para depurar centrado)
const W = this.mmToDots(this.config.labelWidth)
const H = this.mmToDots(this.config.labelHeight)
this.commands.push(`BOX 0,0,${W-1},${H-1},1`)
this.commands.push('CLS')


Si aun así ves todo corrido físicamente, corrige fino con SHIFT ±n (en dots). Ej.: SHIFT -8 mueve 1 mm a la izquierda en 203 dpi.

B) Centrado correcto en dots (no en mm)
1) Utilidad de conversión

Cambia los nombres para que quede claro que manejamos dots:

private mmToDots(mm: number): number {
  return Math.round(mm * (this.config.dpi === 203 ? 8 : 11.811));
}
dotsToMm(dots: number): number {
  return dots / (this.config.dpi === 203 ? 8 : 11.811);
}

2) Ancho de texto (fuentes internas TSC)

Las fuentes internas son mono-ancho por número y se escalan con xMultiplication. Usa una tabla simple (203 dpi; ajustable si tu modelo difiere):

private fontBaseWidthDots(font: string): number {
  // Anchos aproximados por carácter en dots a 203dpi:
  // "1":8, "2":12, "3":16, "4":24, "5":32 (clásico en TSC)
  const map: Record<string, number> = { "1": 8, "2": 12, "3": 16, "4": 24, "5": 32 };
  return map[font] ?? 12; // fallback
}

private textWidthDots(content: string, font: string, xMul: number): number {
  const base = this.fontBaseWidthDots(font);
  return content.length * base * Math.max(1, xMul);
}

3) Ancho de código de barras (fórmulas por simbología)

El truco es trabajar por módulos. En 203 dpi, 1 “narrow” = narrow dots.

CODE128 (A/B/C): cada símbolo usa 11 módulos, más:

Start (11) + Check (11) + Stop (13) + Quiet zones (≥10 módulos por lado).

Total módulos ≈ 11*len + 55

EAN-13: 95 módulos + quiet zones (~9 módulos por lado).

Total módulos ≈ 95 + 18 = 113

private barcodeWidthDots(type: string, data: string, narrowDots: number): number {
  const t = type.toUpperCase();
  if (t === '128' || t === 'CODE128' || t === 'CODE 128') {
    const modules = 11 * data.length + 55; // start+len+check+stop+quiet
    return modules * narrowDots;
  }
  if (t === 'EAN13' || t === 'EAN-13') {
    const modules = 113; // 95 + quiet (~9x2)
    return modules * narrowDots;
  }
  if (t === 'EAN8' || t === 'EAN-8') {
    const modules = 67 + 18; // 67 + quiet aprox
    return modules * narrowDots;
  }
  if (t === 'UPCA' || t === 'UPC-A') {
    const modules = 95 + 18; // similar a EAN13 en ancho base
    return modules * narrowDots;
  }
  // genérico (Code39/93, etc.): aproxima por longitud
  return Math.max(100, data.length * 11 * narrowDots);
}

4) Centrados (devuelven mm porque tus addText/addBarcode usan mm)
getCenteredXDotsForText(content: string, font: string, xMul: number): number {
  const W = this.mmToDots(this.config.labelWidth);
  const w = this.textWidthDots(content, font, xMul);
  return Math.max(0, Math.round((W - w) / 2));
}
getCenteredXDotsForBarcode(type: string, data: string, narrow: number): number {
  const W = this.mmToDots(this.config.labelWidth);
  const w = this.barcodeWidthDots(type, data, this.mmToDots(narrow)); // narrow viene en mm → pásalo a dots
  return Math.max(0, Math.round((W - w) / 2));
}
getCenteredXmmFromDots(xDots: number): number {
  return this.dotsToMm(xDots);
}


Nota: Para barcodes en TSPL, el wide a veces se ignora en Code128 (manda el narrow/módulo). Por eso ahora centramos con módulos reales.

C) Usar el nuevo centrado en tu 51×25

Reemplaza donde calculas titleX/barcodeX/priceX por esto:

if (labelSize === '51x25') {
  // Nombre (máx 16 chars)
  const productName = labelData.name.substring(0, 16);
  const nameXdots = generator.getCenteredXDotsForText(productName, "2", 1);
  const nameX = generator.getCenteredXmmFromDots(nameXdots);
  generator.addText({
    x: nameX, y: 1,
    font: '2', rotation: 0, xMultiplication: 1, yMultiplication: 1,
    content: productName
  });

  // Código de barras (usa tipo detectado y centrado por módulos)
  if (labelData.barcode) {
    const type = detectBarcodeType(labelData.barcode);
    const bcXdots = generator.getCenteredXDotsForBarcode(type, labelData.barcode, /*narrow mm*/ 0.25);
    // 0.25 mm ≈ 2 dots en 203dpi; ajusta a tu lector
    const bcX = generator.getCenteredXmmFromDots(bcXdots);

    generator.addBarcode({
      x: bcX, y: 6,
      codeType: type,
      height: 6,              // mm
      humanReadable: 2,       // HRT centrado
      rotation: 0,
      narrow: 2,              // ¡en TSPL es DOTS! (2 dots ≈ 0.25 mm a 203dpi)
      wide: 2,                // para Code128 no suele aplicar
      content: labelData.barcode
    });
  }

  // Precio
  const priceText = `$${labelData.price.toFixed(2)}`;
  const priceXdots = generator.getCenteredXDotsForText(priceText, "3", 1);
  const priceX = generator.getCenteredXmmFromDots(priceXdots);
  generator.addText({
    x: priceX, y: 16,
    font: '3', rotation: 0, xMultiplication: 1, yMultiplication: 1,
    content: priceText
  });
}


Importante: fíjate que para BARCODE en TSPL los parámetros narrow/wide van en dots, no en mm. Si estabas asumiendo mm, eso causa corrimientos. Con 203 dpi:
1 mm ≈ 8 dots → narrow:2 ≈ 0.25 mm (módulo conservador y legible).

Checklist rápido de calibración

Calibra el gap con el panel/botón de tu impresora (autocalibración).

En comandos, usa GAP 2 mm,0 (o el gap real) y REFERENCE 0,0.

Si la impresión cae corrida aunque tus cálculos estén bien, ajusta con SHIFT ±n (n en dots).

Mantén DIRECTION 1 fijo (no lo alternes entre trabajos, o el origen cambia).

Verifica con el marco BOX que el contenido realmente queda centrado respecto al área imprimible.

Si sigues viendo corrimiento…

Sube/baja narrow (en dots) del barcode: cambia su ancho real y el centrado.

Algunas TSC interpretan wide en Code128 como ignorado; no lo uses para calcular.

Si usas otra fuente (TTF), conviene usar TEXT ... "TTF"... y medir ancho con la métrica de ese TTF (pero eso ya implica otro flujo).